## 一、关于synchronized和volatile

```java
1）三大特性：原子性、可见性、排序性；synchronized能保证原子性、可见性和有序性，但volatile只能保证可见性和有序性，不能保证原子性，因此也称volatile为轻量级synchronized。

2）使用场景：synchronized常用于线程之间同步（要求线程安全的）或者对数据有严格准确要求的并发场景，比如Java中的HashTable、Vector、ConCurrentHashMap
StringBuffer等都使用到了synchronized做线程安全处理。volatile常用于对可用性有要求的场景，比如单例模式中使用双重锁实现的方法。

3）使用方式：synchronized可以用于修饰普通同步方法、静态同步方法、同步方法块。volatile只可修改成员变量

4）synchronized锁类型：
悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。
非公平锁：synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。
可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。
独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。

5）synchrnoized实现原理：在虚拟机中为Monitor对象实现（参见https://www.nowcoder.com/discuss/668295?channel=-1&source_id=profile_follow_post_nctrack） 引申：为什么wait()、notify()等方法要在同步方法或同步代码块中来执行呢，这里就能找到原因，是因为wait()、notify()方法需要借助ObjectMonitor对象内部方法来完成。
答：Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter和 monitorexit 指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。

6）Jdk1.6为什么要对synchronized进行优化？
因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大。

7）jDK1.6对synchronized做了哪些优化？
锁的升级：在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，如下图所示。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级。这种只能升级不能降级的策略是为了提高获得锁和释放锁的效率。
                            无锁=》偏向锁=》轻量级锁=》重量级锁
                            
8）常见偏向锁的面试题：偏向锁的原理（或偏向锁的获取流程）、偏向锁的好处是什么（获取偏向锁的目的是什么）
引入偏向锁的目的：减少只有一个线程执行同步代码块时的性能消耗，即在没有其他线程竞争的情况下，一个线程获得了锁。
偏向锁的获取流程：
1、检查对象头中Mark Word是否为可偏向状态，如果不是则直接升级为轻量级锁。
2、如果是，判断Mark Work中的线程ID是否指向当前线程，如果是，则执行同步代码块。
3、如果不是，则进行CAS操作竞争锁，如果竞争到锁，则将Mark Work中的线程ID设为当前线程ID，执行同步代码块。
4、如果竞争失败，升级为轻量级锁。

一句话简单总结偏向锁原理：使用CAS操作将当前线程的ID记录到对象的Mark Word中。

9）轻量级锁：
引入轻量级锁的目的：在多线程交替执行同步代码块时（未发生竞争），避免使用互斥量（重量锁）带来的性能消耗。但多个线程同时进入临界区（发生竞争）则会使得轻量级锁膨胀为重量级锁。

一句话总结轻量级锁的原理：将对象的Mark Word复制到当前线程的Lock Record中，并将对象的Mark Word更新为指向Lock Record的指针。

10）自旋锁
Java锁的几种状态并不包括自旋锁，当轻量级锁的竞争就是采用的自旋锁机制。

什么是自旋锁：当线程A已经获得锁时，线程B再来竞争锁，线程B不会直接被阻塞，而是在原地循环 等待，当线程A释放锁后，线程B可以马上获得锁。

引入自旋锁的原因：因为阻塞和唤起线程都会引起操作系统用户态和核心态的转变，对系统性能影响较大，而自旋等待可以避免线程切换的开销。

自旋锁的缺点：自旋等待虽然可以避免线程切花的开销，但它也会占用处理器的时间。如果持有锁的线程在较短的时间内释放了锁，自旋锁的效果就比较好，如果持有锁的线程很长时间都不释放锁，自旋的线程就会白白浪费资源，所以一般线程自旋的次数必须有一个限制，该次数可以通过参数-XX:PreBlockSpin调整，一般默认为10。

自适应自旋锁：JDK1.6引入了自适应自旋锁，自适应自旋锁的自旋次数不在固定，而是由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果对于某个锁对象，刚刚有线程自旋等待成功获取到锁，那么虚拟机将认为这次自旋等待的成功率也很高，会允许线程自旋等待的时间更长一些。如果对于某个锁对象，线程自旋等待很少成功获取到锁，那么虚拟机将会减少线程自旋等待的时间。
```



## 二、关于偏向锁、轻量级锁、重量级锁

| 锁    | 优点                                 | 缺点                                       | 使用场景                    |
| ---- | ---------------------------------- | ---------------------------------------- | ----------------------- |
| 偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距  | 如果线程间存在竞争，会额外带来锁撤销的消耗                    | 适用于只有一个线程访问同步块场景（单线程场景） |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度（其实使用的是自旋锁的处理） | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU（自旋会一直暂用CPU，极端情况下会使一些线程一直处于饥饿状态） | 追求响应时间，同步块执行速度非常快       |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                  | 线程阻塞，响应时间缓慢                              | 追求吞吐量，同步块执行速度较慢         |



## 三、了解锁消除吗？

锁消除是指Java虚拟机在即时编译时，通过对运行上下文的扫描，消除那些不可能存在共享资源竞争的锁。锁消除可以节约无意义的请求锁时间。（换句话说就是虚拟机会自动判断程序中的这个锁是不是必要的，如果不必要或者不可能出现共享资源竞争，那么这个锁会“消除”）

```java
public class MySynchronizedTest07 {

    public void method() {
        Object object = new Object();  
        synchronized (object) {  //此处锁是无意义的，因为每次线程访问的时候都会重新生成一个object对象，线程内的对象是私有的，不会产生共享资源的竞争
            System.out.println("hello  world");
        }
    }
————————————————
1、上述代码我们可知将object变成了局部变量，在方法中，方法的的局部变量时线程独立的，并发的场景每个线程都有各自的object对象，这个时候的锁就无意义的。
2、我们在编译上述代码的时候其实也发现了monitorenter和monitorexit，在字节码层面看上去还有有锁的获取和释放。
3、这个时候JIT编译器可以在动态编译同步代码的时候，使用一种叫做逃逸分析的技术（后续学习jvm的时候会涉及到），来通过该技术判断程序中使用的锁对象是否只被一个线程所使用。而没有别的线程进行竞争。当这种情况的下，那么JIT编译器在编译（将字节码编程机器码）这个同步代码时就不会生成synchronized关键字所标识锁的申请和释放的机器码。从而消除锁的使用流程。这就是锁消除的原理和案例。
————————————————

原文链接：https://blog.csdn.net/qq_33249725/article/details/104263831
```



## 四、了解锁粗化吗？

一般情况下，为了提高性能，总是将同步块的作用范围限制到最小，这样可以使得需要同步的操作尽可能地少。但如果一系列连续的操作一直对某个对象反复加锁和解锁，频繁地进行互斥同步操作也会引起不必要的性能消耗。

如果虚拟机检测到有一系列操作都是对某个对象反复加锁和解锁，会将加锁同步的范围粗化到整个操作序列的外部。可以看下面这个经典案例。（换句话说就是程序中锁加多了，实际上用一个锁能解决的时候加了多个锁，会增加锁的开销，因此虚拟机会自动判断是否可以进行锁粗话，减少冗余锁的开销）

```java
public class MySynchronizedTest08 {

    private Object object = new Object();


    public void method() {
      //这里可以用一个锁解决的事情却用了3个锁，因此虚拟机会对此进行粗化处理
        synchronized (object) {
            System.out.println("hello");
        }

        synchronized (object) {
            System.out.println("world");
        }

        synchronized (object) {
            System.out.println("!");
        }
    }
}
————————————————
JIT编译器在执行动态编译的时候。若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块合并成一个较大的同步快，这样做的好处在于线程执行这些代码的时候，就无需频繁申请和释放锁了，从而达到申请与释放一次就可以执行全部的同步代码块，从而提高了性能。
————————————————

原文链接：https://blog.csdn.net/qq_33249725/article/details/104263831
```

